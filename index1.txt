  /*******************************************************
   * index.js - bot whatsapp-web.js + OpenAI (Whisper)
   * - usa gatilhos para todos os audios
   * - primeira mensagem: espera 5s e manda audio inicial
   * - maioria das respostas em audio (prompt for√ßa isso)
   * - transcri√ß√£o de √°udios recebidos
   * - delays humanos; split messages; emojis 20%
   * - follow-ups 1,3,5 minutos -> tenta converter via PIX (teste)
   *******************************************************/

  import { fileURLToPath } from "url";
  import { dirname } from "path";
  import axios from "axios";

  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);

  // dotenv
  import "dotenv/config";

  // libs
  import fs from "fs";
  import path from "path";
  import qrcode from "qrcode-terminal";
  import pkg from 'whatsapp-web.js';
  const { Client, LocalAuth, MessageMedia } = pkg;

  import ffmpeg from "fluent-ffmpeg";
  import { promisify } from "util";

  // fun√ß√£o auxiliar que vc tinha (pode manter)
  function converterParaWhatsApp(filePath) {
    return new Promise((resolve, reject) => {
      const saida = filePath.replace(/\.[^/.]+$/, "_fixed.ogg");
      ffmpeg(filePath)
        .audioCodec("libopus")
        .audioChannels(1)
        .audioFrequency(48000)
        .audioBitrate("64k")
        .toFormat("ogg")
        .on("end", () => resolve(saida))
        .on("error", reject)
        .save(saida);
    });
  }

  // openai
  import OpenAI from "openai";

  // configura√ß√£o
  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
  const TEST_PIX = process.env.TEST_PIX || "12988356980"; // coloque aqui o pix de teste ou via .env

  // cliente whatsapp
  const client = new Client({ authStrategy: new LocalAuth() });

  client.on("qr", (qr) => {
    console.log("üì± escaneie este QR (whatsapp do celular que ser√° a IA):");
    qrcode.generate(qr, { small: true });
  });
  client.on("ready", () => console.log("ü§ñ bot conectado no WhatsApp!"));

  // ------------------------------------------------------------------
  //  lista completa de audios hospedados no Google Drive
  //  (ALTERA√á√ÉO: array de objetos {file, url})
  // ------------------------------------------------------------------
  const audiosDrive = [
    { file: "fixed_prontinho__so_ascessar_o_conteudo.ogg", url: "https://drive.google.com/uc?export=download&id=1Lw-KiIv9V7pzPUvYG_djcuHtLiio7Frh" },
    { file: "fixed_to_indo_pra_acad.ogg", url: "https://drive.google.com/uc?export=download&id=1Be41WQoXIxNFhWzt8H5tGdRHk2e-Ee7Y" },
    { file: "fixed_voce_que_me_ver_peladinha.ogg", url: "https://drive.google.com/uc?export=download&id=1bEJqkr6FxmNZtV_VcYrziyCMP3Z8VTAz" },
    { file: "fixed_salva_meu_contato.ogg", url: "https://drive.google.com/uc?export=download&id=1y18Kgjargpxy1NAx3Mu6H2WYk0nMp9Yv" },
    { file: "fixed_quer_q_te_explique.ogg", url: "https://drive.google.com/uc?export=download&id=1ed1g_2JA1ATIhDretNZ3EXmQziw2p0Mm" },
    { file: "fixed_pra_me_ver_nua_tem_que_comprar_os_packs.ogg", url: "https://drive.google.com/uc?export=download&id=19drb30U3fwSzRe8nS_HtCZFw4QTR-P0H" },
    { file: "fixed_pra_vc_me_ver_pelada_tem_que_pagar.ogg", url: "https://drive.google.com/uc?export=download&id=1RhZarneh_YSBn1QME9mi4CbjMmpktRCL" },
    { file: "fixed_vou_ter_enviar_minhas_foto.ogg", url: "https://drive.google.com/uc?export=download&id=1aTuUjUh2bYkfPovuJMgoIkSSGDZ7NTbR" },
    { file: "fixed_saio_com_quem_ja_e_meu_cliente.ogg", url: "https://drive.google.com/uc?export=download&id=1gNds3pXyV_YYYzCUqzVg2BTirgw4IMst" },
    { file: "fixed_vc_demora_muito_pra_responder.ogg", url: "https://drive.google.com/uc?export=download&id=1ownw2nY3MooknDGkC6Fzykaq-QgS-nSg" },
    { file: "fixed_sou_de_vdd.ogg", url: "https://drive.google.com/uc?export=download&id=1YLtFCKezM5MimKRJLi2J8P0ujzcTd7Qz" },
    { file: "fixed_pedindo_pra_aguardar.ogg", url: "https://drive.google.com/uc?export=download&id=1Q3Th_tFRd8eVk5e5FHHy9C9nrkIBVvAB" },
    { file: "fixed_oi_gatinho_lindo.ogg", url: "https://drive.google.com/uc?export=download&id=1y5f5jizqFJHqZ1ygfaAooY3VlkoJWq-t" },
    { file: "fixed_ja_to_com_sdd.ogg", url: "https://drive.google.com/uc?export=download&id=1kfcn88RS2rVIIDwtd8pK5eBWQkqRVgjn" },
    { file: "fixed_mensagem_direta_pra_compra_.ogg", url: "https://drive.google.com/uc?export=download&id=1BDiti38QyZpy2XHORz8-N7aiJavCuGyU" },
    { file: "fixed_gravei_me_gozando_todinha.ogg", url: "https://drive.google.com/uc?export=download&id=1qzTAxv1OrmiQyJXmkM3onx2cZRJf1Q3H" },
    { file: "fixed_o_que_achou_das_amostras.ogg", url: "https://drive.google.com/uc?export=download&id=1JID4OZ8lY6ddDKnXfrsUKjiSrRAxPfSS" },
    { file: "fixed_oi_meu_amor_tudo_bem.ogg", url: "https://drive.google.com/uc?export=download&id=1HFtIUitU4ja79_8WhP1RhOPUj3RmXn5k" },
    { file: "fixed_bom_dia_meu_cliente_favorito.ogg", url: "https://drive.google.com/uc?export=download&id=11qw_EAYgmZF2MydCXIpdSZJd1-ny_to-" },
    { file: "fixed_a_nao_esquece_de_manda_o_comprovante.ogg", url: "https://drive.google.com/uc?export=download&id=1hFNadVThTjCw9EfFLTJ4nR4o65Rxh6uX" },
    { file: "Bom dia-N√£o sou fake.ogg", desc: "cumprimento e prova social", url: "https://drive.google.com/uc?export=download&id=1nn8otk8CBGXp2GC-_4NIIgRdiKPkw4dj" },
  ];
  /* ALTERADO: agora que audiosDrive j√° existe, criamos allAudios e o mapa */
  const allAudios = audiosDrive.map(a => a.file); // usado no prompt
  const audiosDriveMap = Object.fromEntries(audiosDrive.map(a => [a.file, a.url]));

  // --- LISTA DE PR√âVIAS (Google Drive direct links) ---
  const previasDrive = [
    { file: "previa_1.jpeg", url: "https://drive.google.com/uc?export=download&id=12n9RVlR9cN7xVXr6QSQH5GapAuqpT9iL" },
    { file: "previa_2.jpeg", url: "https://drive.google.com/uc?export=download&id=1CZrx02GOe8CrcZQdIR_PDtQDnJXNUbt0" },
    { file: "previa_3.jpeg", url: "https://drive.google.com/uc?export=download&id=1hy9mcH-ArD7HHqpOp0tlOTep-PvbF0Ec" },
    { file: "previa_4.jpeg", url: "https://drive.google.com/uc?export=download&id=1iW9A4vMN9ivpDT_nMBQHpgck4LoXPnJX" },
    { file: "previa_5.jpeg", url: "https://drive.google.com/uc?export=download&id=1py6G5KMDG07oUCUnJQ8jj3AEXCMRSQ8J" },
    { file: "previa_6.jpeg", url: "https://drive.google.com/uc?export=download&id=1qrizknmLvPeboTmFU0PuehnoXEZz695d" },
    { file: "previa_7.jpeg", url: "https://drive.google.com/uc?export=download&id=1tDDl78pRCb_oV4xaLJ-WCeEJ4c0hcaQq" },
    { file: "previa_8.jpeg", url: "https://drive.google.com/uc?export=download&id=1wdwmOuABNSqE_TIgp6VXBWgjXAwzApA2" },
    { file: "previa_9.jpeg", url: "https://drive.google.com/uc?export=download&id=1wwMpjuFyYVeXhByYlMao1S7EjvwE24gC" },
  ];
  const previasMap = Object.fromEntries(previasDrive.map(p => [p.file, p.url]));

  // --- LISTA DE √ÅUDIOS DISPON√çVEIS ---
  const audiosDisponiveis = [
    "audio_1.mp3", "audio_2.mp3", "audio_3.mp3", "audio_4.mp3",
    "audio_5.mp3", "audio_6.mp3", "audio_7.mp3", "audio_8.mp3"
  ];

  // --- CONTROLES DE REPETI√á√ÉO ---
  let previasEnviadas = new Set();
  let audiosEnviados = new Set();

  // --- GATILHOS ---
  const gatilhosPrevia = [
    "pr√©via", "previa", "foto", "imagem", "mostra", "mostrar",
    "ver", "manda", "envia", "me mostra", "me manda", "tem a√≠",
    "deixa eu ver", "tem algo", "tem alguma", "quero ver", "cad√™ a pr√©via"
  ];
  const gatilhosAudio = [
    "√°udio", "audio", "voz", "fala comigo", "quero te ouvir",
    "manda um √°udio", "me manda √°udio", "me manda sua voz",
    "grava pra mim", "me fala com sua voz"
  ];

  // --- FALAS PROVOCANTES ---
  const falasProvocantes = [
    "hm?", "u√© rs", "fala mais disso üòè", "s√©rio?",
    "assim voc√™ me deixa curiosa üòú", "continua‚Ä¶", "gostei disso üò∂‚Äçüå´Ô∏è",
    "ah √©? üëÄ", "me convence melhor ent√£o rs"
  ];

  // --- FUN√á√ïES AUXILIARES ---
  function pegarAleatorioUnico(lista, enviados) {
    const disponiveis = lista.filter(i => !enviados.has(i.file || i));
    if (disponiveis.length === 0) {
      enviados.clear();
      return pegarAleatorioUnico(lista, enviados);
    }
    const escolhido = disponiveis[Math.floor(Math.random() * disponiveis.length)];
    enviados.add(escolhido.file || escolhido);
    return escolhido;
  }

  function enviarMensagem(texto) {
    console.log("üí¨ Enviado:", texto);
  }

  // --- DELAY GLOBAL DE 6 SEGUNDOS ---
  function delay(ms = 6000) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // --- FUN√á√ÉO PRINCIPAL ---
  async function responderLead(mensagem) {
    const msgLower = mensagem.toLowerCase();

    const querPrevia = gatilhosPrevia.some(t => msgLower.includes(t));
    const querAudio = gatilhosAudio.some(t => msgLower.includes(t));

    await delay(); // ‚è≥ aguarda 6s antes de qualquer resposta

    if (querPrevia) {
      const previa = pegarAleatorioUnico(previasDrive, previasEnviadas);
      const provocacao = falasProvocantes[Math.floor(Math.random() * falasProvocantes.length)];
      enviarMensagem(`${provocacao}\n<PREVIA: ${previa.url}>`);
      return;
    }

    if (querAudio) {
      const audio = pegarAleatorioUnico(audiosDisponiveis, audiosEnviados);
      const provocacao = falasProvocantes[Math.floor(Math.random() * falasProvocantes.length)];
      enviarMensagem(`${provocacao}\n<<AUDIO:${audio}>>`);
      return;
    }

    const respostaAleatoria = falasProvocantes[Math.floor(Math.random() * falasProvocantes.length)];
    enviarMensagem(respostaAleatoria);
  }

  // --- EXEMPLOS ---
  // responderLead("me manda uma pr√©via");
  // responderLead("quero ouvir sua voz");
  // responderLead("fala mais disso");


  // ------------------------------------------------------------------
  //  mapa de gatilhos -> NOME do arquivo de audio (RECOMENDADO)
  //  ‚ö†Ô∏è IMPORTANTE: aqui n√≥s usamos nomes (ex: "fixed_oi_gatinho_lindo.opus")
  // ------------------------------------------------------------------
  // ------------------------------------------------------------------
  // mapa de gatilhos -> nome do arquivo de √°udio existente no Drive
  // ------------------------------------------------------------------
  const audioTriggers = {
    "bom dia": "fixed_bom_dia_meu_cliente_favorito.ogg",
    "vc √© fake": "fixed_sou_de_vdd.ogg",
    "vc √© real": "fixed_sou_de_vdd.ogg",
    "fake": "fixed_sou_de_vdd.ogg",
    "comprovante": "fixed_a_nao_esquece_de_manda_o_comprovante.ogg",
    "pix": "fixed_mensagem_direta_pra_compra_.ogg",
    "pagar": "fixed_mensagem_direta_pra_compra_.ogg",
    "compra": "fixed_mensagem_direta_pra_compra_.ogg",
    "link": "fixed_mensagem_direta_pra_compra_.ogg",
    "quero pack": "fixed_pra_me_ver_pelada_tem_que_pagar.ogg",
    "amostra": "fixed_oi_gatinho_lindo.ogg",
    "mostra": "fixed_oi_gatinho_lindo.ogg",
    "gratis": "fixed_oi_gatinho_lindo.ogg",
    "gostosa": "fixed_gravei_me_gozando_todinha.ogg",
    "gozar": "fixed_gravei_me_gozando_todinha.ogg",
    "goze": "fixed_gravei_me_gozando_todinha.ogg",
    "pelada": "fixed_pra_me_ver_pelada_tem_que_pagar.ogg",
    "nua": "fixed_pra_me_ver_pelada_tem_que_pagar.ogg",
    "saudade": "fixed_ja_to_com_sdd.ogg",
    "sdd": "fixed_ja_to_com_sdd.ogg",
    "demora": "fixed_vc_demora_muito_pra_responder.ogg",
    "salva": "fixed_salva_meu_contato.ogg",
    "prontinho": "fixed_prontinho__so_ascessar_o_conteudo.ogg",
    "duvida": "fixed_quer_q_te_explique.ogg",
    "explica": "fixed_quer_q_te_explique.ogg",
    "oi": "fixed_oi_gatinho_lindo.ogg",
    "ol√°": "fixed_oi_meu_amor_tudo_bem.ogg",
    "tudo bem": "fixed_oi_meu_amor_tudo_bem.ogg",
  };

  // ------------------------------------------------------------------
  // mem√≥ria + timers
  // ------------------------------------------------------------------
  const firstAudioName = "fixed_oi_gatinho_lindo.ogg";
  const memoryStore = {}; // conversas por contato
  const followTimers = {}; // timers por contato

  // util: escreve log curto
  function log(...args) {
    console.log(new Date().toISOString(), ...args);
  }

  // util delay (ms)
  function sleep(ms) {
    return new Promise((res) => setTimeout(res, ms));
  }

  function deveUsarAudio(mensagem) {
    const palavras = mensagem.split(" ").length;
    const chance = Math.random();

    if (palavras < 3) return false; // respostas curtas: s√≥ texto
    if (mensagem.includes("?")) return chance < 0.5; // metade das perguntas em √°udio
    return chance < 0.3; // 30% das respostas comuns em √°udio
  }

  /* === ALTERADO: nova vers√£o da fun√ß√£o sendAudioHuman (envia direto do Drive) === */
  function getMimeByName(name) {
    const ext = (name || "").split(".").pop().toLowerCase();
    if (ext === "opus") return "audio/opus";
    if (ext === "ogg") return "audio/ogg; codecs=opus";
    if (ext === "mp3") return "audio/mpeg";
    if (ext === "m4a") return "audio/mp4";
    return "audio/ogg";
  }

  async function sendAudioHuman(from, audioName) {
    try {
      if (!audioName || typeof audioName !== "string") {
        console.error("‚ùå Nome do arquivo inv√°lido:", audioName);
        await sendTextHuman(from, "ops, meu √°udio bugou üòÖ");
        return;
      }

      const audioUrl = audiosDriveMap[audioName];
      if (!audioUrl) {
        console.error("‚ùå √Åudio n√£o encontrado no audiosDriveMap:", audioName);
        await sendTextHuman(from, "n√£o achei esse √°udio agora üòÖ");
        return;
      }

      // baixa o arquivo direto (arraybuffer)
      const resp = await axios.get(audioUrl, {
        responseType: "arraybuffer",
        maxRedirects: 5,
        timeout: 15000,
      });

      // checa content-type simples (opcional)
      const contentType = resp.headers && (resp.headers['content-type'] || resp.headers['Content-Type']);
      if (contentType && !contentType.startsWith("audio")) {
        console.warn("‚ö†Ô∏è Resposta do Drive n√£o tem content-type audio:", contentType);
        // ainda assim tentamos enviar, mas aviso no log
      }

      const buffer = Buffer.from(resp.data);
      const base64 = buffer.toString("base64");
      const mime = getMimeByName(audioName);

      // cria MessageMedia diretamente a partir do base64
      const media = new MessageMedia(mime, base64, audioName);

      // envia como voz (PTT)
      await client.sendMessage(from, media, { sendAudioAsVoice: true });

      console.log(`‚úÖ √Åudio enviado: ${audioName} -> ${from}`);
    } catch (err) {
      console.error("‚ùå Erro ao enviar √°udio do Drive:", err?.message || err);
      try { await sendTextHuman(from, "tive um probleminha ao enviar o √°udio, me espera..."); } catch (e) { /* fallback */ }
    }
  }

  /* === Envia m√≠dia de visualiza√ß√£o √∫nica (foto/v√≠deo) === */
  async function sendPreviaOnce(from, fileName) {
    try {
      const url = previasMap[fileName];
      if (!url) {
        console.error("‚ùå Pr√©via n√£o encontrada:", fileName);
        await sendTextHuman(from, "n√£o achei minha pr√©via agora üòÖ");
        return;
      }

      // baixa o arquivo
      const resp = await axios.get(url, { responseType: "arraybuffer", timeout: 15000 });
      const buffer = Buffer.from(resp.data);
      const base64 = buffer.toString("base64");

      // detecta mime b√°sico
      const mime = url.endsWith(".mp4")
        ? "video/mp4"
        : url.endsWith(".png") || url.endsWith(".jpeg") || url.endsWith(".jpg")
        ? "image/jpeg"
        : "application/octet-stream";

      const media = new MessageMedia(mime, base64, fileName);

      // envia com visualiza√ß√£o √∫nica
      await client.sendMessage(from, media, { viewOnce: true });
      console.log(`‚úÖ Pr√©via enviada (viewOnce): ${fileName} -> ${from}`);
    } catch (err) {
      console.error("‚ùå Erro ao enviar pr√©via:", err?.message || err);
      await sendTextHuman(from, "tive um probleminha pra te mandar a pr√©via üò¢");
    }
  }


  /* sendTextHuman (mantive igual, s√≥ usei client.sendMessage) */
  async function sendTextHuman(from, text, isFirst = false) {
    if (!text) return;
    const lowerText = String(text).toLowerCase();
    const addEmoji = !isFirst && Math.random() < 0.2;
    const emoji = addEmoji ? " üòò" : "";
    const shouldSplit = Math.random() < 0.3 && lowerText.length > 30;

    if (shouldSplit) {
      const parts = lowerText.split(/[,.!?]/).map(p => p.trim()).filter(Boolean);
      const first = parts[0] || lowerText;
      const rest = parts.slice(1).join(", ") || "";
      await sleep(2000 + Math.random() * 2000);
      await client.sendMessage(from, first + emoji);
      if (rest) {
        await sleep(2000 + Math.random() * 3000);
        await client.sendMessage(from, rest);
      }
      return;
    }

    await sleep(2000 + Math.random() * 2000);
    await client.sendMessage(from, lowerText + (addEmoji ? emoji : ""));
  }

  // fun√ß√£o para checar gatilho de audio
  function checkAudioTrigger(text) {
    if (!text) return null;
    const lower = text.toLowerCase();
    for (const key in audioTriggers) {
      if (lower.includes(key)) {
        return audioTriggers[key]; // retorna NOME do arquivo
      }
    }
    return null;
  }

  // grava mem√≥ria da conversa por contato
  function pushMemory(from, role, content) {
    if (!memoryStore[from]) memoryStore[from] = [];
    memoryStore[from].push({ role, content });
    if (memoryStore[from].length > 16) memoryStore[from].shift();
  }

  // reseta follow-ups (cancela timers)
  function resetFollowUps(from) {
    if (!followTimers[from]) return;
    for (const t of followTimers[from]) clearTimeout(t);
    delete followTimers[from];
  }

  // agenda follow-ups de 1,3,5 minutos (cada um tenta empurrar PIX e usa audios)
  function scheduleFollowUps(from) {
    resetFollowUps(from);
    followTimers[from] = [];

    // 1 min: lembrete suave (audio ou texto)
    const t1 = setTimeout(async () => {
      log("followup 1m -> lembrete suave:", from);
      // suave: audio de amostra ou sauda√ß√£o
      const f = checkAudioTrigger("amostra") || firstAudioName;
      if (f && audiosDriveMap[f]) {
        await sendAudioHuman(from, f);
      } else {
        await sendTextHuman(from, "e ai amor, ficou olhando? quer que eu te mande uma amostra r√°pida?", false);
      }
    }, 60 * 1000);
    followTimers[from].push(t1);

    // 3 min: press√£o m√©dia - pede pix de teste suave
    const t3 = setTimeout(async () => {
      log("followup 3m -> pressao media:", from);
      const file = checkAudioTrigger("sdd") || "fixed_ja_to_com_sdd.opus";
      if (file && audiosDriveMap[file]) {
        await sendAudioHuman(from, file);
      } else {
        await sendTextHuman(from, "amor, to aqui ainda, se quiser ver mais tem que garantir seu acesso ok", false);
      }
      await sleep(3000 + Math.floor(Math.random() * 2000));
      await sendTextHuman(from, `quer testar ? faz um pix de r$20 pro numero ${TEST_PIX} e eu te libero uma amostra exclusiva`, false);
    }, 3 * 60 * 1000);
    followTimers[from].push(t3);

    // 5 min: ultima chance - press√£o final e desistir
    const t5 = setTimeout(async () => {
      log("followup 5m -> pressao final:", from);
      const finalAudio = checkAudioTrigger("prontinho") || "fixed_prontinho_so_acessar_o_conteudo.opus";
      if (finalAudio && audiosDriveMap[finalAudio]) {
        await sendAudioHuman(from, finalAudio);
      } else {
        await sendTextHuman(from, "ultima chance meu amor, se quiser continuar sem pressa me chama, se quiser td liberado faz o pix de r$20 pro numero " + TEST_PIX, false);
      }
      await sleep(2 * 60 * 1000);
      await sendTextHuman(from, "vou deixar pra la agora, quando quiser me chama de novo üíã", false);
      delete memoryStore[from];
      resetFollowUps(from);
    }, 5 * 60 * 1000);
    followTimers[from].push(t5);
  }

  // fun√ß√£o que chama OpenAI e for√ßa resposta em formato que queremos
  async function askOpenAI(from, userText) {
    pushMemory(from, "user", userText);

    const systemPrompt = `
  voc√™ √© uma garota sexy que vende packs e v√≠deos.
  fale sem letra mai√∫scula, com pouca pontua√ß√£o.
  as mensagens devem ser curtas, naturais e provocantes, parecendo bem humanas.

  use humor leve e ironia sutil, e sempre termine com um gancho pra manter o lead engajado.
  apenas 20% das mensagens podem ter 1 emoji (no m√°ximo).

  üî• CONTROLE DE CLIMA E PROGRESS√ÉO

  quanto mais tempo a conversa durar, mais √† vontade voc√™ fica ‚Äî fala mais solta, mais direta e confiante.
  varie o tom entre provocante, brincalhona e curiosa, dependendo do humor do lead.

  üéß USO DE √ÅUDIOS

  voc√™ deve usar os √°udios dispon√≠veis abaixo como gatilhos.
  sempre analise se o contexto da conversa abre brecha pra um deles (por exemplo, se o lead pede pra ver algo, demora pra responder, fala de academia, etc).
  se fizer sentido, envie o √°udio e um texto curtinho junto.

  use exatamente a sintaxe:
  <<AUDIO:nome-do-arquivo.ext>>

  se nenhum √°udio fizer sentido, responda com um texto curto (1‚Äì2 frases), natural e provocante.

  Tabela de √°udios dispon√≠veis:

  Nome do √°udio	Contexto sugerido
  fixed_prontinho__so_ascessar_o_conteudo.ogg	quando envia algo pronto
  fixed_to_indo_pra_acad.ogg	se ele falar de academia
  fixed_voce_que_me_ver_peladinha.ogg	se ele pedir pra ver algo
  fixed_salva_meu_contato.ogg	quando pede pra manter contato
  fixed_quer_q_te_explique.ogg	quando ele parece confuso
  fixed_pra_me_ver_nua_tem_que_comprar_os_packs.ogg	se ele quiser ver sem pagar
  fixed_pra_vc_me_ver_pelada_tem_que_pagar.ogg	mesmo contexto, mais direta
  fixed_vou_ter_enviar_minhas_foto.ogg	quando for falar de fotos
  fixed_saio_com_quem_ja_e_meu_cliente.ogg	quando fala de sair pessoalmente
  fixed_vc_demora_muito_pra_responder.ogg	se ele demorar pra responder
  fixed_sou_de_vdd.ogg	pra refor√ßar que √© real
  fixed_pedindo_pra_aguardar.ogg	quando precisa que ele espere
  fixed_oi_gatinho_lindo.ogg	pra iniciar o papo de forma fofa
  fixed_ja_to_com_sdd.ogg	se j√° tiver rola de intimidade
  fixed_mensagem_direta_pra_compra_.ogg	pra converter em venda
  fixed_gravei_me_gozando_todinha.ogg	pra provocar mais
  fixed_o_que_achou_das_amostras.ogg	ap√≥s mandar pr√©vias
  fixed_oi_meu_amor_tudo_bem.ogg	pra reaproximar
  fixed_bom_dia_meu_cliente_favorito.ogg	iniciar o dia
  fixed_a_nao_esquece_de_manda_o_comprovante.ogg	lembrete de pagamento
  Bom dia-N√£o sou fake.ogg	prova social/confian√ßa
  üëÄ PR√âVIAS (VISUALIZA√á√ÉO √öNICA)

  voc√™ tem 9 pr√©vias de visualiza√ß√£o √∫nica.
  todas t√™m o mesmo n√≠vel ‚Äî escolha qualquer uma quando fizer sentido.

  s√≥ envie <<PREVIA:nome-da-previa>> se o lead demonstrar interesse visual
  (ex: ‚Äúquero ver‚Äù, ‚Äúmostra‚Äù, ‚Äútem foto?‚Äù, ‚Äúcomo √© voc√™?‚Äù) ou se o clima estiver rolando.

  ap√≥s enviar, reaja de forma provocante:
  ‚Äúgostou?‚Äù, ‚Äúacha muito?‚Äù, ‚Äúquer ver mais rs‚Äù, ‚Äúfala o que achou üòè‚Äù.

  Tabela de pr√©vias:

  Nome da pr√©via	Link
  previa1	https://drive.google.com/file/d/12n9RVlR9cN7xVXr6QSQH5GapAuqpT9iL/view?usp=sharing

  previa2	https://drive.google.com/file/d/1CZrx02GOe8CrcZQdIR_PDtQDnJXNUbt0/view?usp=sharing

  previa3	https://drive.google.com/file/d/1hy9mcH-ArD7HHqpOp0tlOTep-PvbF0Ec/view?usp=sharing

  previa4	https://drive.google.com/file/d/1iW9A4vMN9ivpDT_nMBQHpgck4LoXPnJX/view?usp=sharing

  previa5	https://drive.google.com/file/d/1py6G5KMDG07oUCUnJQ8jj3AEXCMRSQ8J/view?usp=sharing

  previa6	https://drive.google.com/file/d/1qrizknmLvPeboTmFU0PuehnoXEZz695d/view?usp=sharing

  previa7	https://drive.google.com/file/d/1tDDl78pRCb_oV4xaLJ-WCeEJ4c0hcaQq/view?usp=sharing

  previa8	https://drive.google.com/file/d/1wdwmOuABNSqE_TIgp6VXBWgjXAwzApA2/view?usp=sharing

  previa9	https://drive.google.com/file/d/1wwMpjuFyYVeXhByYlMao1S7EjvwE24gC/view?usp=sharing
  üí¨ FALLBACK INTELIGENTE

  se n√£o houver nada √≥bvio pra responder, apenas reaja de forma curta e provocante:
  ‚Äúhm?‚Äù, ‚Äúu√© rs‚Äù, ‚Äúfala mais disso‚Äù, ‚Äúvc √© assim sempre? üòè‚Äù.
  ${allAudios.map(a => `- ${a}`).join("\n")}
  `;

    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [{ role: "system", content: systemPrompt }, ...(memoryStore[from] || [])],
        temperature: 1.0,
        max_tokens: 220,
      });
      const reply = completion.choices[0].message.content.trim();
      pushMemory(from, "assistant", reply);
      return reply;
    } catch (err) {
      log("erro openai:", err?.response?.data || err?.message || err);
      throw err;
    }
  }

  // ------------------------------------------------------------------
  // EVENT: mensagem recebida
  // ------------------------------------------------------------------
  client.on("message", async (msg) => {
    const from = msg.from;
    const hasMemory = !!memoryStore[from];

    // sempre cancela os followups ao receber qualquer mensagem do lead
    resetFollowUps(from);

    // se for a primeira mensagem (lead novo)
    if (!hasMemory) {
      memoryStore[from] = [];
      pushMemory(from, "user", msg.body || "[audio]");

      // aguardamos 5s e mandamos o audio inicial fixo (agora do Drive)
      setTimeout(async () => {
        try {
          if (firstAudioName && audiosDriveMap[firstAudioName]) {
            await sendAudioHuman(from, firstAudioName);
          } else {
            await sendTextHuman(from, "oie, tudo bem? sou eu mesmo aqui üíï", true);
          }
        } catch (e) {
          log("erro enviando audio inicial:", e);
        }
        scheduleFollowUps(from);
      }, 5000);
      return;
    }

    // se a mensagem tem media (audio do lead) - vamos transcrever
    let text = msg.body || "";
    try {
      if (msg.hasMedia) {
        const media = await msg.downloadMedia();
        const ext = (media.mimetype || "audio/ogg").split("/")[1].split(";")[0];
        const tmpName = path.join(__dirname, `tmp_${Date.now()}.${ext}`);
        fs.writeFileSync(tmpName, Buffer.from(media.data, "base64"));

        try {
          const transcription = await openai.audio.transcriptions.create({
            file: fs.createReadStream(tmpName),
            model: "whisper-1",
          });
          text = transcription.text || "";
          log("transcricao audio:", text);
        } catch (e) {
          log("erro transcrever audio:", e?.response?.data || e?.message || e);
        } finally {
          if (fs.existsSync(tmpName)) fs.unlinkSync(tmpName);
        }
      }
    } catch (err) {
      log("erro processando media:", err);
    }

    // registra texto recebido
    pushMemory(from, "user", text);
    log("mensagem do lead:", text);
    try {
      const reply = await askOpenAI(from, text) || "";
      const replyText = String(reply || "");
    
      // gatilho por texto (checa audioTriggers -> retorna nome do arquivo)
      const trig = checkAudioTrigger(text);
      if (trig && audiosDriveMap[trig]) {
        await sendAudioHuman(from, trig);
        scheduleFollowUps(from);
        return;
      }
    
      // tag no reply <<AUDIO: nome>>
      const audioMatch = replyText.match(/<<AUDIO:\s*([^>]+)>>/i);
      if (audioMatch) {
        const fname = audioMatch[1].trim();
        if (audiosDriveMap[fname]) {
          await sendAudioHuman(from, fname);
        } else {
          await sendTextHuman(from, "amor, to com um probleminha aqui, me espera um pouquinho", false);
        }
      } else {
        // decide se envia √°udio aleat√≥rio ou texto
        if (Math.random() < 0.7 && audiosDrive.length > 0) {
          const randIndex = Math.floor(Math.random() * audiosDrive.length);
          const randomAudioFile = audiosDrive[randIndex].file;
          if (audiosDriveMap[randomAudioFile]) {
            await sendAudioHuman(from, randomAudioFile);
          } else {
            await sendTextHuman(from, replyText, false);
          }
        } else {
          await sendTextHuman(from, replyText, false);
        }
      }
    // detecta tag de pr√©via
  const previaMatch = replyText.match(/<<PREVIA:\s*([^>]+)>>/i);
  if (previaMatch) {
    const pfile = previaMatch[1].trim();
    if (previasMap[pfile]) {
      await sendPreviaOnce(from, pfile);
    } else {
      await sendTextHuman(from, "ops, n√£o encontrei essa pr√©via agora üòÖ");
    }
    scheduleFollowUps(from);
    return;
  }

      scheduleFollowUps(from);
    } catch (err) {
      console.error("Erro no processamento da mensagem:", err);
      await sendTextHuman(from, "ops, tive um errinho aqui amor, me espera um segundinho üíï", false);
      scheduleFollowUps(from);
    }
  }); // fecha client.on("message", ... )

  // inicializa cliente
  client.initialize();
